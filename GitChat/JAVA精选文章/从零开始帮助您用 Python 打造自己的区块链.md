### 前言

2018 年 4 月以来，随着加密货币价格的回升，各种关于区块链的话题甚嚣尘上，各大媒体对其商业性质、技术原理、发展前景各个方面，都有各种非常深入的探讨。同时，新的项目、概念也层出不穷，让人眼花缭乱。笔者认为，“区块链” 本质上还是一种软件算计 / 架构上的创新。只有自己搭建环境，编写代码，实现从建立账本到完成交易的全过程，才能真正体会区块链的精髓。

![比特币近十年来的价格逐波上升](http://images.gitbook.cn/f8b90ff0-4ccb-11e8-9d85-bdd8a53e41f6)比特币近十年来的价格逐波上升

本场 Chat 的目的是，就是帮助广大的区块链爱好者或者开发人员，从零开始打造属于您自己的区块链应用。力求用最简单的语言，介绍这个最热门的技术，没有任何基础的读者也能按图索骥，一窥究竟，消除各种专家为其增添的很多迷思。

本文首先将介绍一些区块链的背景知识，而后将循序渐进地介绍在本地开发区块链应用所需要的模块和算法，做出一个简单的区块链交易程序。在此过程中，会穿插很多关于相关名字、术语、算法的解释。相关源代码都保存在笔者的 [GitHub 项目](https://github.com/marmul2/blockchain)中，欢迎读者直接使用或者提交修改申请（pull request）。

> GitHub 是一个面向开源及个人软件项目的托管平台，因为只支持 git 作为唯一的版本管理格式，故名 GitHub。因为这里聚集了超过 350 万开发者，其中又以男性程序员为主，所以被戏称为 “全球最大同性交友网站”。它不光支持代码的发布、管理，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱、代码片段分享等功能。任何用户都可以在其上保存和发布自己的个人项目，很多知名的开源项目如 Ruby on Rails、jQuery、python 等都托管在该平台上。

### 1. 区块链简介

一位名为 “中本聪” (Satoshi Nakamoto) 的人于 2008 年 11 月 1 日，在 [metzdowd.com](http://metzdowd.com/)网站的密码学邮件列表中，发表了一篇名为《比特币：一种点对点式的电子现金系统》(Bitcoin: A Peer to Peer Electronic Cash System) 的论文，首次提出了 “区块链”（Blockchain）的概念。白皮书发布之后不久，中本聪于 2009 年 1 月 3 日，开发出首个实现了比特币算法的客户端程序，并进行了首次 “采矿”，获得了第一批 50 个比特币。这标志着比特币的正式诞生。中本聪出于知识分享和推广的理念，把比特币程序的代码全部开源，与世界各地的软件开发人员共同分享。

![中本聪的论文](http://images.gitbook.cn/b5d0a7b0-4ccc-11e8-856b-c3783bde05e6)中本聪的原始论文

经过这十年的发展，区块链已经发展成为全球最具影响力的创新技术之一。从金融行业、制造产品到教育机构的各行各业，都可能会被这项技术全面改造。它的三大最主要的特点是：

- 去中心化交易

区块链的本质是一种分散在所有用户电脑上（即所谓的 “分布式”）的计算机账本，每个分散的账本会记录区块链上进行的所有交易活动的信息。所以，它不需要一个集中的机构、网站、公司来管理这些信息。

> 法国大作家大仲马在 1884 这年出版的小说《三个火枪手》中有这么一句著名的话，“人人为我，我为人人”（All for one, one for all）。用这句话来形容区块链的去中心化特征非常贴切。

- 信息不可篡改，一旦写入无法改变

作为一个记录交易的账本，人们最不希望的是它被坏人恶意篡改。任何一个用户，都可以通过交易编号，访问区块链上发生的所有交易记录和注释。由于中本聪巧妙的算法设计，配合密码限制和共识机制，如果要修改区块链中的某一个数据，就必须更改其后发生的所有数据记录，计算量无可想象，非常庞大，几乎不可能实现。实际上，比特币诞生到现在已经接近 10 年，每天都有无数的黑客绞尽脑汁攻击这个系统，但是从来没有发生过一起交易记录被篡改的事件，这足以证明了它的安全性。

- 完全匿名

在互联网诞生初期，有句话说：“在互联网上，没人知道你是一只狗。” 这强调的是在互联网上的匿名访问性。在区块链世界里，所有的账户（或者说 “钱包”）都是通过一个密码来访问。如果你失去了密码，也就失去了账户里面的所有货币。在现实生活中，如果你忘记了密码或者丢失了银行卡，你可以去银行柜台申请补办，手续很简单。但是在 “去中心化” 的区块链世界里，没有这样的 “银行柜台”，谁也不知道你是谁，你也无法向别人证明你是某个钱包的主人。

当然，与大部分技术一样，区块链也是一个 “双刃剑”，有它的不足之处：

- 过度消耗能源

想要生成一个新的区块，必须要大量服务器资源进行大量无谓的尝试性计算进行 “挖矿”，严重耗费电能（后文将详细介绍 “挖矿” 的过程）。

- 信息的网络延迟

以比特币为例，任何一笔交易数据都需要同步到其他所有节点，同步过程中难免会受到网络传输延迟的影响，带来较长的耗时。

区块链应用的实际开发，可以分为以下几步。下面我们将针对每个步骤详细介绍。除了主要介绍环境配置的第二节和介绍交易步骤的第七节以外，其他步骤都分为概念介绍、代码实现、深入讲解这三个部分。所有代码均已放在我的 [GitHub 项目](https://github.com/marmul2/blockchain)之中，您可以直接下载使用。如果对具体的代码实现不感兴趣，您也可以直接只关注每节中的概念介绍和深入讲解这两个部分。如果您对具体的算法也不感兴趣，没关系，您可以直接跳过这些部分，进入第七节，逐步尝试自己完成 “虚拟交易”。

![enter image description here](http://images.gitbook.cn/0c440d60-4da1-11e8-856b-c3783bde05e6)

### 2. 环境配置：建立 “交易所”

为了便于初学者学习，笔者会尽可能详细地记录开发环境配置的每一个步骤，如果您已经熟悉 Python 环境和相关模块的使用，您可以选择跳过这一部分。

1. 首先，您需要一台安装了 Win7 或者 Win10 系统的电脑，可以是台式机或者是笔记本电脑。当然，不一定非要用 Windows 系统来开发区块链应用，Linux 或者 Mac 系统也是很好的选择，这里我们为了照顾大部分读者，只介绍 Windows 系统下的操作。

2. 访问 [www.python.org](https://www.python.org/downloads/)，下载并安装 Python 3.6.5 或者将来的更高版本。

   ![enter image description here](http://images.gitbook.cn/dc4ce140-4cce-11e8-8fbb-d5dabcf6ef11)下载Python

   ​

3. 安装完毕 Python 之后，从 Windows 的开始菜单输入 “cmd”：

![enter image description here](http://images.gitbook.cn/2e7d2e00-4cfe-11e8-856b-c3783bde05e6)

在命令行窗口输入以下指令，安装 Flask 和 requests 库。Flask 库将用于在本地构建一个 Web 服务器，把 Python 的功能映射到一定的端口，便于我们稍后通过针对不同的地址终端（endpoint）发送 HTTP 请求，执行各项交易，从而构成我们自己的 “虚拟交易所” ；requests 库则用于自动发送 HTTP 请求到服务器。

```
c:\>easy_install pip
c:\>pip install Flask==0.12.2 requests==2.18.4

```

1. 访问 <https://www.getpostman.com/apps>， 下载并安装 Postman，它可以把我们定制的交易内容，发送到我们的 “虚拟交易所”。

   ![enter image description here](http://images.gitbook.cn/1b4b7fd0-4d08-11e8-9d85-bdd8a53e41f6)Postman的开始界面

   ​

2. 现在，打开电脑在带的写字板编辑器，保存这样一个文件到 D:\hello.py:

```
from flask import Flask
app = Flask(__name__)
@app.route('/')
def hello_world():
    return '您好，欢迎来到我的虚拟货币交易所!'

```

这里实际上用的 Flask 模块的路由功能，具体语法信息请参阅 [Flask 介绍页面](http://flask.pocoo.org/docs/0.12/quickstart/#a-minimal-application)。

1. 回到命令行控制界面，输入下列指令：

```
c:\>set FLASK_APP=D:\hello.py
c:\>python -m flask run

```

你可以看到屏幕显示 “Running on https://127.0.0.1:5000/”。 这时，打开你的浏览器，访问 https://127.0.0.1:5000/， 你可以看到这样的显示结果：

![enter image description here](http://images.gitbook.cn/65525390-4e04-11e8-9d85-bdd8a53e41f6)交易所开始运行

这就意味着，我们的运行环境已经搭建成功，您的 “虚拟交易所” 已经准备好接受交易了！

### 3. 构建区块链：把 “区块” ，“链” 到一起

#### 概念介绍

“区块链”（Blockchina）可以理解为把一个个符合特定格式的区块（Block），按照一定的方法 “链”（chain）到一起。

![enter image description here](http://images.gitbook.cn/ea144d00-4d0e-11e8-9d85-bdd8a53e41f6)

这里先预习几个需要涉及的概念：

> “类” （class）：类是面向对象程序设计中的概念，是面向对象编程的基础。类是对现实生活中一类具有共同特征的事物的抽象，譬如区块链这个概念，就是一类具有共同特征的事物，我们可以用一个类来代表它。类可以描述一个对象（在本文中即某个区块链）能够做什么，以及做的方法（method）。
>
> 哈希值（Hash）：所谓 “哈希值” 就是计算机可以对任意内容，计算出一个长度相同的特征值。区块链的哈希值长度是 256 位，这也就是说，不管原始内容是什么，最后都会计算出一个 256 位的二进制数字。而且可以保证，只要原始内容不同，对应的哈希一定是不同的。举例来说，字符串 123 的哈希值是 a8fdc205a9f19cc1c7507a60c4f01b13d11d7fd0（十六进制），转成二进制就是 256 位，而且只有 123 能得到这个哈希。（理论上，其他字符串也有可能得到这个哈希，但是概率极低，可以近似认为不可能发生。） 由此可以得到两个重要的结论：
>
> - 结论 1：每个区块的哈希都是不一样的，可以通过哈希标识一个区块。
> - 结论 2：如果区块的内容变了，它的哈希一定会改变。

#### 代码实现

首先，我们要用一个构造函数来创建一个区块链类 ，其中包括两个表：一个用于存储区块，一个用于记录交易。另外，我们还要定义一个方法，用于生成区块的哈希值。此外，我们还为这个类定义了一个属性 last_block， 这样可以通过调用该类获得区块链中最后一个区块的信息。下面是这个类的初步结构：

```
class Blockchain(object):
    def __init__(self):
        self.chain = []
        self.current_transactions = []

    def new_block(self):
        # 创建一个新的区块
        pass

    def new_transaction(self):
        # 把新的交易添加到交易列表中
        pass

    @staticmethod
    def hash(block):
        # 生成一个区块的哈希值
        pass    

    @property
    def last_block(self):
        # 返回链中的最后一个区块
        pass

```

这个类负责管理整个区块链，包括存储交易信息，把新的区块添加到整个区块链之中。下面，我们再来看看一个典型的区块是什么样的，以及它们是怎么构成一条区块链的。按照中本聪的原始定义，下面是一个典型的区块：

```
block = {
    'index': len(self.chain) + 1,
    # 区块编号，即区块链之前长度+1
    'timestamp': time(),
    # 区块生成时间的UNIX时间戳
    'previous_hash': previous_hash or   self.hash(self.chain[-1]),
    #上一个区块的哈希值，另外需要考虑第一个区块的情况
   'proof'：proof,
    # 工作量证明（PoW），稍后会详细介绍
    'transactions': [
        {
        'sender': sender_hash,
        #付款人钱包地址
        'recipient': recipient_hash,
        #收款人钱包地址
        'amount': tranactions_ammount,
        #交易金额
        }
   ],
    # 区块中的交易信息
 }

```

#### 深入讲解

由上面的定义可以看出，一个区块包括下面几项内容：

- 区块索引 / 编号

- 区块产生时间

- 上一个区块的哈希值

- 工作量证明（PoW）

- 交易信息

  ​

  ![enter image description here](http://images.gitbook.cn/fdcc3190-4e09-11e8-8fbb-d5dabcf6ef11)

  ​

  这揭示了区块链的核心理念：每个区块中包含了上一个区块的哈希值或者说信息。这一点对区块链有重大意义：如果有人修改了一个区块，该区块的哈希值就变了。为了让后面的区块还能连到它，就必须依次修改后面所有的区块，否则被改掉的区块就脱离区块链了。由于哈希值的计算非常耗时（后面将解释原因），短时间内修改多个区块几乎不可能发生，除非有人真的掌握了全球网络中 51% 以上的计算能力。正是通过这种联动机制，区块链保证了自身的可靠性，数据一旦写入，就无法被篡改。这就像历史一样，发生了就是发生了，从此再无法改变。每个区块都连着上一个区块，这也是 "区块链" 这个名字的由来。

### 4. 记录交易： 怎么给区块添加交易记录？

#### 概念介绍

在建立起区块链之后，接下来我们看看怎么为其添加交易信息。所谓 “交易”（Transaction）的过程，实际上就是给区块链加一笔数据更新的记录，其中包含了付款人的钱包地址、收款人的钱包地址、交易金额。如果把区块链作为一个状态机，则每次交易就是试图改变一次状态，而每次生成的区块，就是参与者对于区块中交易导致状态改变的结果进行确认。

#### 代码实现

具体的添加过程，是通过 new_transaction 这个方法来实现的。下面是对这个方法的定义实例。

```
def new_transaction(self, sender, recipient, amount):
   self.current_transactions.append({
   'sender': sender,
   # 付款人的钱包地址
   'recipient': recipient,
   # 收款人的钱包地址
   'amount': amount,
   # 交易金额
   })
   return self.last_block['index'] + 1
   # 返回当前区块链最后一个区块的索引值加1，即下一个区块的索引值

```

> 钱包：比特币的所有权是通过数字密钥、比特币地址和数字签名来确定的，数字密钥实际上并不是存储在网络中，而是由用户生成并存储在一个文件或简单的数据库中，这就是所谓的 “钱包”。一切的所有权，都体现在这个唯一的数字密钥文件上。经常发生的情况是，很多人看到比特币价格大涨，想起来自己在多年前曾经在某台电脑上保存过一个钱包文件，但是可惜要不电脑已经丢了，要不就是密码忘了。另外，经常有媒体报道，有某个加密货币交易平台被盗，黑客窃走多少比特币云云。实际上，谁也没有办法判断，这些丢失的比特币，是被黑客偷走了，还是被交易平台的管理者通过修改密码的方法偷偷据为己有了。

#### 深入讲解

简单来说，每笔交易的核心，就是一句话，比如 "张三向李四转移了 N 个比特币"。区块链作为一个数据库，记录了所有这些交易的信息。当然，为了证明这句话可行，需要给每笔交易加上数字签名，而后任何人都可以用张三的公钥，证明这确实是张三本人的行为。另一方面，其他人无法伪造张三的数字签名，所以不可能伪造这笔交易。关于数字签名和非对称加密的具体过程，由于篇幅限制，本 Chat 将不涉及，笔者将会在另外的课程中详述。

### 5. “挖矿” 解密

#### 概念介绍

上面我们介绍了交易的概念。但是，交易只是一笔笔财富转移的记录，并不会创造财富。那么，“真金白银” 的比特币到底是从哪里来的呢？ 这就涉及到了 “挖矿”。也就是说，每个比特币，都是通过挖矿这种活动所产生的。

在区块链网络中，存在着成千上万的网络节点。为了保证节点之间的同步，新区块的添加速度不能太快。试想一下，你刚刚同步了一个区块，准备基于它生成下一个区块，但这时别的节点又有新区块生成，你不得不放弃做了一半的计算，再次去同步。因为每个区块的后面，只能跟着一个区块，你永远只能在最新区块的后面，生成下一个区块。所以，你别无选择，一听到信号，就必须立刻同步。所以，区块链的发明者中本聪故意让添加新区块，变得很困难。他的设计是，平均每 10 分钟，全网才能生成一个新区块，一小时也就六个。

这种产出速度不是通过命令达成的，而是故意设置了海量的计算。也就是说，只有通过极其大量的计算，才能得到当前区块的有效哈希值，从而把新区块添加到区块链。由于计算量太大，所以快不起来。这个过程就叫做挖矿（Mining），因为计算有效哈希值的难度，就好像在全世界的沙子里面，找到一粒符合条件的沙子。计算哈希的机器就叫做 “矿机”，操作矿机的人就叫做 “矿工”。

之所以计算这个有效哈希值很难，是因为不是任意一个哈希值都可以，只有满足条件的哈希值才会被区块链接受。这个条件特别苛刻，使得绝大部分哈希值都不满足要求，必须重算。在区块中包含了一个难度系数（Difficulty），这个值决定了计算哈希值的难度。举例来说，第 100000 个区块的难度系数是 14484.16236122。区块链协议规定，使用一个常量除以难度系数，可以得到目标值（Target）。显然，难度系数越大，目标值就越小。然而，只有小于目标值的哈希才是有效的，否则哈希无效，必须重算。

由于目标值非常小，哈希值小于该值的机会极其渺茫，可能计算 10 亿次，才算中一次。这就是采矿如此之慢的根本原因。前面说过，一个区块的哈希值是唯一的。如果要对同一个区块反复计算哈希值，就意味着区块必须不停地变化，否则不可能算出不一样的哈希值。区块里面所有的特征值都是固定的，为了让区块产生变化，中本聪故意增加了一个随机项，叫做 Nonce。

Nonce 是一个随机值，“矿工” 的工作其实就是猜出 Nonce 的值，使得区块的哈希值可以小于目标值，从而能够写入区块链。Nonce 是非常难猜的，目前只能通过穷举法一个个试错。根据协议，Nonce 是一个 32 位的二进制值，即最大可以到 21.47 亿。第 100000 个区块的 Nonce 值是 274148111，可以理解成，矿工从 0 开始，一直计算了 2.74 亿次，才得到了一个有效的 Nonce 值，使得算出的哈希值能够满足条件。

运气好的话，也许一会就找到了 Nonce。运气不好的话，可能算完了 21.47 亿次，都没有发现 Nonce，即当前区块体不可能算出满足条件的哈希值。这时，协议允许矿工改变区块体，开始新的计算。

简单来说，工作量证明或者说挖矿算法，目的就是寻找一个特殊的数字，使得哈希值（即 SHA256 函数）的输出字符串的前 n 位是零。

#### 代码实现

现在，我们可以把这个算法简化成一个数学题：一个整数 x 乘以另一个整数 y 的积的 哈希值必须以 0 结尾，即 hash(x * y) = ac23dc...0。设 x = 5，求 y 的值？

下面是用 Python 求解这个数学题的代码：

```
from hashlib import sha256
x = 5 
y = 0  # 从0开始穷举，直到生成的哈希值符合条件为止
while sha256(f'{x*y}'.encode()).hexdigest()[-1] != "0": 
    y += 1
print(f'y= {y}')

```

结果是： y = 21。因为，生成的 Hash 值结尾必须为 0。 hash(5 * 21) = 1253e9373e...5e3600155e860

这就意味着经过 22 次尝试，我们成功地找到了一个 Nonce，也得到了一个符合要求的哈希值，这样就完成了一次 “挖矿”， 可以生成一个区块了。

在此基础上，下面是一个简化版的挖矿算法（也就是工作量证明) 的问题和求解代码：

- 找到一个使得 pp'的哈希值包含 4 个 0 的数字 p'
- p 是上一个工作量证明值，p'是新的证明值

```
def proof_of_work(self, last_proof):
    proof = 0
    while self.valid_proof(last_proof, proof) is False:
        proof += 1
    return proof

```

#### 深入讲解

要调节挖矿的难度，实际上就是控制需要哈希值包含的 0 的个数。实际上，四个 0 已经相当具有挑战性了，随着 0 的数目一个一个增加，需要的计算时间将会呈指数级增长。

简单来说，“挖矿” 的过程其实类似于打麻将， 四方最后有一方凑出了胡牌的牌型，就当与生成了一个达到要求的区块哈希值，胡牌的人就成了 “矿工”，得到相应的奖赏 （比特币）。 胡完一牌，就是一个区块生成，所以当前交易记录在内。然后大家接着下一局，继续凑胡牌牌型。

如果一句没有人胡牌，也就是大家花了时间，但是没有生成区块，就重新开局。如果投入的时间 / 资源小于获得的奖赏，这个矿工就亏了。但是, 如果有人摸了两把就胡牌了，相当于很快就找到了这个哈希值, 这个矿工就大赚了。

### 6. 在网络中传播区块链：共识算法

#### 概念介绍

上面我们学会了怎么在同一个节点（或者说计算机）上构建区块链的主要功能，例如挖矿和进行交易。但是，区块链的关键就在于去中心化，也就是说我们需要在不同的节点上部署类似的功能。

这样的话，怎么样确保所有节点都在使用同一个区块链呢？中本聪为此提出了著名的 “共识算法”： 如果一个节点的区块链与另外一个节点的不同，这就意味着冲突。解决这个问题的办法就是，“最长的有效的链” 应当获得认可。 换句话说，网络上最长的链就是事实上的标准链。利用这种算法，我们可以在我们网络中的所有节点中达成共识。

![enter image description here](http://images.gitbook.cn/19aee3f0-4e12-11e8-856b-c3783bde05e6)

用户会保留最长的区块链，即第一行

#### 代码实现

要判断 “最长的有效的链”，我们可以分为两步。首先，判断某个给定的区块链是否有效：

```
def valid_chain(self, chain):
    last_block = chain[0]
    current_index = 1
    while current_index < len(chain):
        block = chain[current_index]
        print(f'{last_block}')
        print(f'{block}')
        print("\n-----------\n")
    # 检查区块的哈希值是否正确
        if block['previous_hash'] != self.hash(last_block):
         return False
    # 检查工作量证明是否正确
        if not
        self.valid_proof(last_block['proof'], 
        block['proof']):
         return False
        last_block = block
        current_index += 1
    return True

```

下一步是使用消除冲突的 “共识算法”。原理是将本节点上区块链和网络上所有节点的区块链做比较。一旦在网络上找到了一个有效的区块链，而且长度比本节点的区块链长，我们就换用这个区块链。具体的实现如下：

```
 def resolve_conflicts(self):
        neighbours = self.nodes
        new_chain = None
        # 寻找比当前链长的区块链
        max_length = len(self.chain)
        # 从网络中所有节点获取区块链并加以验证
        for node in neighbours:
            response = requests.get(f'http://{node}/chain')
        # 从节点的网络端口获取区块链信息
            if response.status_code == 200:
        # HTTP请求返回状态字200表示成功
                length = response.json()['length']
                chain = response.json()['chain']
        # 检查区块链的长度和是否有效
                if length > max_length and self.valid_chain(chain):
                    max_length = length
                    new_chain = chain
        # 一旦找到了一个有效的链，而且长度比本节点的链长，就换用这个区块链
        if new_chain:
            self.chain = new_chain
            return True

        return False

```

#### 深入讲解

“共识算法” 的本质，是选择计算量最大的链条最为主链条。这样，即使有人恶意破坏，也要付出大量的经济成本，达到不可承受的程度。

举个例子来说，超市付款需要排成一队，可能有人不守规矩要插队，这样分出好几条队伍。超市管理员会检查队伍，找出最长的一条队伍是合法的，奖励其中拍得久的人，并让不合法的分叉队伍重新排队。只要大部分人不傻，就会自觉在最长的队伍上排队。

### 7. 执行交易

到目前为止，我们已经讲解了所有主要的规则和算法，下面我们就可以开始实际交易了。作为一个区块链或者加密货币的普通使用者，可能并不需要关心起其核心算法是什么，但是需要了解交易的过程意味着什么。这就如同一个购买股票的交易者，可能并不需要知道交易所采用了什么样的通信技术，但是要知道自己买卖股票的步骤。在这里笔者将引导您以用户的身份，在自己创建的 “虚拟交易所” 中进行交易。

交易的过程，实际上就是通过 HTTP 请求，告诉服务器（或者说交易所）我们想要做什么。为此，我们将使用 Python Flask 框架。如前所述，这是一个轻量 Web 应用框架，它所提供的 API 可以把网络请求映射到 Python 函数。这里，我们将创建三个接口（endpoint）：

> /transactions/new： 创建一个交易并添加到区块
>
> /mine： 告诉服务器去挖掘新的区块
>
> /chain： 展示当前整个区块链的信息

我们的 “Flask 服务器” 将扮演区块链网络中的一个节点。我们先添加一些框架代码：

```
# 初始化节点
app = Flask(__name__)
# 为该节点生成一个唯一的地址
node_identifier = str(uuid4()).replace('-', '')
# 初始化区块链
blockchain = Blockchain()
@app.route('/mine', methods=['GET'])
# 建立一个用于访问挖矿功能的网址终端，即/mine；请求类型为GET
def mine():
    return "挖一个新的区块"
@app.route('/transactions/new', methods=['POST'])
# 建立一个用于访问添加交易功能的网址终端，即/transactions/new；请求类型为POST
def def new_transaction():
    return "添加交易到Y区块"
@app.route('/chain', methods=['GET'])
# 建立获取当前区块链信息的网址终端，即/chain；请求类型为GET
def def full_chain():
    return "区块链信息"

```

现在，我们就可以直接对我们的交易所发出请求了。

- 下载并保存 [blockchain.py](https://github.com/marmul2/Frank-Blockchain/blob/master/blockchain.py) 到本地硬盘中, 用 Python 自带编辑器打开。![enter image description here](http://images.gitbook.cn/cdb3db40-4e1b-11e8-8fbb-d5dabcf6ef11)

![enter image description here](http://images.gitbook.cn/881ee610-4e1b-11e8-856b-c3783bde05e6)

- 然后按下 F5，或者从菜单中选择 Run -> Run Module.

  ​

  ![enter image description here](http://images.gitbook.cn/0ead2840-4e1c-11e8-9d85-bdd8a53e41f6)

  ​

  这时屏幕显示 “交易所” 已经运行，地址为 http://0.0.0.0:5000.

  ​

  ![enter image description here](http://images.gitbook.cn/af4c8030-4e1b-11e8-8fbb-d5dabcf6ef11)

  ​

- 这时，我们可以用我们在第二节中安装的 Postman，发出一个 GET 请求，申请挖矿：http://localhost:5000/mine![enter image description here](http://images.gitbook.cn/1d6f9470-4e1d-11e8-9d85-bdd8a53e41f6)

- 接着，我们可以通过发出一个 POST 请求，申请创建交易： http://localhost:5000/transactions/new。 在发送这个请求时，需要提供交易信息，下面是一个例子：

![enter image description here](http://images.gitbook.cn/871b5160-4e1e-11e8-9d85-bdd8a53e41f6)

- 我接着又通过向 http://localhost:5000/mine 发出两次请求，挖了两个区块，最后发出一个 GET 请求，查看这个区块链的信息 http://localhost:5000/chain:

![enter image description here](http://images.gitbook.cn/79ff7e60-4e1f-11e8-9d85-bdd8a53e41f6)

这样，我们就完成了三个最主要的交易步骤。

### 后记

本 Chat 中所有的代码都放置在我的 GitHub 项目 “[Frank—Blockchain](https://github.com/marmul2/Frank-Blockchain)” 上，请自由索取或者提交修改。或者您也可以分叉（fork）一个自己的分支，创建您自己的区块链项目。开句玩笑话，这就像是在麻将的基本原则基础上，开辟出各种分支：四川麻将、上海麻将等等。

希望本 Chat 能帮助您了解并实践区块链的基本概念和实现方法。请注意，这里提到的只是区块链最核心的部分，还有很多很多其他的技术细节和算法，譬如非对称加密、点对点网络等，我将会在以后的其他 Chat 中详细说明。如果有任何其他的问题，欢迎到我的读者圈中继续提问。

#### 参考资料

- 中本聪： [《比特币：一种点对点式的电子现金系统》( Bitcoin: A Peer to Peer Electronic Cash System)](https://bitcoin.org/bitcoin.pdf)
- Sean Han：[How does blockchain really work?](https://medium.freecodecamp.org/how-does-blockchain-really-work-i-built-an-app-to-show-you-6b70cd4caf7d)