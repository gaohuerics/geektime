## 内容提要

内容提要：

- 能否写一个简单接口的小案例，让我们理解更加透彻一点？
- 如果接口粒度比较细，那么一个功能页面会调用很多个接口来完成展示。这种情况有什么办法优化吗？
- 在开发接口的时候调用方添加缓存来避免接口的调用次数，接口提供方也有缓存，这样造成了缓存的混乱，缓存失效时间不一致。这种问题你遇见过吗？
- 能否用一个开发过程中简单的实例来分析一下如何设计和清晰地开发出一个接口？
- 接口的访问权限和登录信息验证，从耦合度方面一般如何处理？
- 接口设计，给不同业务方提供服务，同一个接口通过入参区分来源？还是不同接口？哪种更合理？
- 关于接口的数据缓存，请问是怎么做的？我目前是使用Nginx对get请求做数据缓存，还有别的好方式吗？
- 接口服务降级，人工降级还是自动降级？熔断机制如何优雅地引入？

------

**问：能否写一个简单接口的小案例，让我们理解更加透彻一点？**

**答：**我用魅族生活服务抢电影券的接口来举个列子。下面是1.0版本的一个时序图。

![img](https://i.imgur.com/G73CMvY.png)

这个肯定是不可能撑住的。我们会对各个点进行优化。

1. 因为抢券功能涉及到流量大，为了不影响其他功能，需要进行业务隔离，首先单独机器部署，然后就是把抢券这个模块、缓存、DB最好都进行隔离。
2. 我们发现DB根本扛不住，这时候我们将数据全部加在了redis里面。读写都在redis里面，可以采用redis队列。
3. 抢的人太多了，我们需要设置一些过滤条件。我们这边会对IMEI、userId、IP地址、黑名单用户进行过滤。
4. 券异步绑定，提示语，券稍后会发放到你账户上。
5. 我们发现请求图片还是很慢，我们继续采用hybrid模式，因为活动一般变化比较快，我们也做了很多模板，如果是html的话，还要load js以及css、图片等，客户预加载资源包到本地。
6. 正常用户客户端单位时间内点击多次只会请求一次。
7. 进行一些限流，Nginx进行了限流、以及guava限流。

下图是2.0版本。

![img](https://i.imgur.com/3hZyycH.png)

这时候我们发现，还是有问题，万一redis挂了，这时候我们做了一个redis集群外，还采用了域名访问来redis，也做了一些降级，重新load数据等机制以及数据的重加载。

------

**问：如果接口粒度比较细，那么一个功能页面会调用很多个接口来完成展示。这种情况有什么办法优化吗？**

**答：**这种一个页面需要调用多个接口组装数据来完成展示是常态，我觉得该拆分就得拆分，不然假如这个接口需要从N多个数据源来获取数据除了增加接口的响应时间外，也不利于业务的稳定性，一个接口有问题导致整个功能不能用。如果拆分的话，可以保证主流程接口没问题就行。如果不拆分，为了保证接口的稳定性，有个数据源的话，那么做隔离也是一件痛苦的事。如果有多个数据源的话，那么做隔离也是一件痛苦的事。一个页面一个接口返回的话，一旦页面有任何改动，你就得对这个接口进行修改，而且还要兼容以前的版本，要么就重新做一个接口，不利于接口的稳定和扩展性。

------

**问：在开发接口的时候调用方添加缓存来避免接口的调用次数，接口提供方也有缓存，这样造成了缓存的混乱，缓存失效时间不一致。这种问题你遇见过吗？**

**答：**首先是否使用缓存，个人觉得有以下几个原则：

1. 热点数据，即需要频繁访问的数据，对于冷数据缓存，还没访问就已经失效，意义不大。
2. 读取多更新少的数据，比较适合缓存；而对于更新频繁的数据，一般来说不太适合进行缓存，当然也有例外，比如像是用户的收藏数、点赞数等，这种访问频繁、更新频繁的数据，可以进行缓存以减轻数据库的压力。
3. 要缓存的数据能容忍一定时间内不一致或者有更新机制。

综上，对于您提到的这个问题，按我的理解，这些接口数据是符合第三个原则的，对于接口调用方，如果做了缓存，并且希望缓存不一致的时间短一些，可以缩短调用方/客户端的缓存失效时间(具体可以根据接口提供方的缓存时间来进行评估)，这样的话既可以降低数据不一致的时间，也能降低接口被调用的频繁程度。对于接口提供方缓存的一致性保证，可以通过rpc服务或者mq的形式进行实时通知更新，确保更新了数据库后可以同步更新缓存，以此达到缓存的一致性。只能具体业务具体分析，比如身份证实名认证，肯定得持久化并且缓存起来。

------

**问：能否用一个开发过程中简单的实例来分析一下如何设计和清晰地开发出一个接口？**

**答：**这个问题和第一个问题差不多。问题1里面少了一些相关的数据库。我觉得接口首先要考虑数据的来源，然后根据数据的来源来设计会更清晰。接口其实不在乎提供数据，但我们要想到数据从哪里来，怎么来，如果是第三方的话，我们是通过同步还是异步拿，如果是自己的业务的话，需不需要做缓存，我们需要考虑自己的数据存储以及获取方式。

------

**问：接口的访问权限和登录信息验证，从耦合度方面一般如何处理？**

**答：**其实这两个都是权限控制的，一个是登陆验证，一个是接口访问限制。做过openApi相关的会比较清楚。我个人觉得登陆权限先获取，然后在看是否有访问权限，就像开放平台这边，你需要申请一个openId和key等，然后再申请对应的接口权限。当然具体业务具体分析，离开业务就是空谈。

------

**问：接口设计，给不同业务方提供服务，同一个接口通过入参区分来源？还是不同接口？哪种更合理？**

**答：**如果是提供同样的数据的话，就一个接口搞定，如果是不同的数据就采用三个接口。如果接口访问量很大，可以水平拆分出来。

------

**问：关于接口的数据缓存，请问是怎么做的？我目前是使用Nginx对get请求做数据缓存，还有别的好方式吗？**

**答：**做缓存有多种方式：客户端本地缓存、guava本地缓存、redis分布式缓存等。Nginx缓存也是一种。这边我觉得合适最重要。如果数据要求实时性不那么高，就像很多App里面有很多栏目分类、城市等信息我觉得更适合做客户端本地缓存。

对于这个问题：

1. 进行签名验证；
2. 走http协议的话可以head进行一些验证，比如refer等；
3. 走auth2.0认证，拿token验证；
4. 走https。

其实数据的缓存方案有多种：代理曾缓存、服务本地缓存和分布式缓存，对于在代理层做缓存，推荐可以了解一下[openresty](http://openresty.org/cn/)。

------

**问：接口服务降级，人工降级还是自动降级？熔断机制如何优雅地引入？**

**答：**服务降级肯定是自动降级，能做成自动降级的就做成自动降级。如果代码层面的降级推荐hystrix。hystrix能解决很多问题，而且不会引入一大堆代码。降级的话，主要对服务异常进行降级。我们需要评估出会出现服务异常的地方，比如是第三方服务，如果出现异常，需要planB，或者一些单点引起的。



## 文章实录



### 接口设计需要考虑哪些方面

1. 接口的命名。
2. 请求参数。
3. 支持的协议。
4. TPS、并发数、响应时长。
5. 数据存储。DB选型、缓存选型。
6. 是否需要依赖于第三方。
7. 接口是否拆分。
8. 接口是否需要幂等。
9. 防刷。
10. 接口限流、降级。
11. 负载均衡器支持。
12. 如何部署。
13. 是否需要服务治理。
14. 是否存在单点。
15. 接口是否资源包、预加载还是内置。
16. 是否需要本地缓存。
17. 是否需要分布式缓存、缓存穿透怎么办。
18. 是否需要白名单。

当我们设计接口，我们或多或少都会有上面列举的一些考虑，我们只有想的更多才能让让我们的接口更加完善，我个人觉得100%完美的接口是不存在，只有适合才是最重要。

### 接口设计原则

原则一：必须符合Restful，统一返回格式，约定业务层错误编码，每个编码可以携带可选的错误信息。

原则二： 命名必须规范、优雅。

原则三：单一性。

单一性是指接口要做的事情应该是一个比较单一的事情，比如登陆接口，登陆完成应该只是返回登陆成功以后一些用户信息即可，但很多人为了减少接口交互，返回一大堆额外的数据。比如有人设计一个用户列表接口，接口他返回每一条数据都是包含用户了一大堆跟另外无关的数据，结果一问，原来其他无关的数据是他下一步想要获取的，想达成数据的懒加载

原则四：可扩展。

接口扩展性，是指设计接口的时候多想想多种情况，多考虑各个方面，其实我觉得单独将扩展性放在这里也是不妥的，感觉说的跟单一性有点相反的意思，其实这个不是这个意思，这边的扩展性是指我们的接口充分考虑客户端，想想他们是如何调用的，他要怎样使用我的代码，他会如何扩展我的代码，不要把过多的工作写在你的接口里面，而应该把更多的主动权交给客户程序员。如获取不同的列表数据接口，我们不可能将每个列表都写成一个接口。 还有一点，我这里特别想指出来的是很多开发人员为了省事（姑且只能这么理解），将接口设计当成只是app页面展示，这些人将一个页面展示就用一个接口实现，而不考虑这些数据是不是属于不同的模块、是不是属于不同的展示范畴、结果下次视觉一改，整个接口又得重写，不能复用。

原则五：必须有文档。

良好的接口设计，离不开清晰的接口文档表述。文档表述一定要足够详细

原则六：产品心。

为什么我说要有产品心？因为我觉得很多人忽略了这一点。我来说一下假如开发一个app，如果一开始连个交互文档给你都没有的话，你怎么设计接口？所以我觉得作为一个服务端后台开发人员应该要有产品心，特别是对于交互文档应该好好理解，因为这些都会对我们的接口设计有很大的影响，我在设计接口的时候就很常发现很多交互文档根本就走不通，产品没有考虑到位，交互文档缺失，这时候作为一个开发要主动推动，完善。

原则七：第三方服务接口数据能缓存就缓存。

原则八：第三方服务需要做降级。

原则九：建议消除单点。

原则十：接口粒度要小。

原则十一：客户端能处理的逻辑就不要给服务端处理，减少服务端压力。

原则十二：资源预加载。

原则十三：不要过度设计。

原则十四：缓存尽量不要穿透。

原则十五：接口能缓存就缓存。

原则十六：思辨大于执行

### 如何保证接口的高可用、高性能

上面也列举很多需要考虑和设计的原则，其实还有很多方面，我这边也不是特别全面。居于上面列举的这些考虑点，其实这边说服务是更恰当，能把上面说的点做好，其实接口也是比较可靠，如何设计以及保证接口的高可用和高性能。可以思考一下以下几个point

高性能：如果我们发现这个接口tps和响应时间没有达到我们的要求怎么办。

- A：数据存储方面：我们会想数据库有没有分库、分表、有没有做主从，有没有读写分离、字段是否有加索引、是否存在慢sql，数据库引擎是否选用合适、是不是用了事务；其次我们会想到是不是引用了分布式缓存、缓存key大小是否合适，失效时间是否设置合理，会不会大量缓存穿透、有没有引入本地缓存。
- B：业务方面：是否有大量的计算、能否异步处理。是否需要引入线程池或者MQ来异步处理任务。有没有必要将接口进行垂直拆分和水平拆分、将接口粒度变小。
- C：其他方面：nginx层面做缓存、加机器、用ssd，资源放cdn，多机房部署、资源文件预加载。

高可用：如何保证服务高可用，需要从几个维度来实现：

- A：消除单点，基于高可用第二位。
- B：能做集群的全部做集群。譬如Redis集群、mysql集群、MongoDB副本集。
- C：能做读写分离的都做读写分离。
- D：异地多机房部署，接入GSLB
- E：必须有限流、降级机制。
- F：监控。高可用的保证，基于第一位。

下图是从一个基本的请求出发来梳理需要涉及到各个段，以及各个端能做的事情。谈谈接口服务，但不局限于接口本身。

![enter image description here](http://images.gitbook.cn/d41aa2f0-ced9-11e7-9266-f33e05c7660a)

1. 客户端：资源预加载、限制请求、数据上报。我这边就拿客户端来举个例子。接口服务所依赖的资源包或者一些公共配置预加载在本地，减少接口的交互，通过请求配置文件是否更新，code是否是304等来；接口做一些请求限制，比如抢红包、抢券等，单位时间内N次点击只请求一次等；接口失败数据上报来；这就是客户端可以做到的对接口有帮助的事情
2. GSLB/HttpDNS：多机房部署、流量切换、域名劫持，一般技术和业务比较成熟的公司这一层。
3. 资源文件放CDN。
4. 负载均衡器：lVS+Nginx是互联网常用的做负载均衡，可以实现四层/七层负载均衡；这里除了可以分流、转发以外，我们用的更多的基于令牌桶限流、缓存。
5. 本地缓存。本地缓存能减少我们访问DB或者分布式缓存，本地缓存推荐使用guava，guava里面有很多特性很好用，例如基于令牌桶的限流；当缓存失效时只穿透一个请求去访问后端。
6. 线程池。
7. 模块拆分。将一个项目按功能模块拆分，一个接口也可以按业务粒度进行拆分。
8. 数据中心。提供数据支撑，譬如黑名单。
9. 数据库。加索引、分库、分表、读写分离
10. 分布式缓存。数据分片、拆分大key，并做集群，采用分布式锁
11. MQ。做接口拆分利器，异步操作。
12. 其他服务。限流、防刷以及降级（特别是第三方服务，保证第三方服务down掉不要影响我们自身的服务）。在这里也需要考虑做第三方数据的缓存或者持久化，譬如实名认证、身份证认证等。
13. 监控。监控永远是必须的，能让你第一时间知道接口服务是否ok

### 个人小分享

**1）接口Restful，统一返回格式，约定业务层错误编码，每个编码可以携带可选的错误信息**

在前司，客户端和服务之间是有统一的数据返回格式，约定各层的编码，可以通过编码位数以及编码就可以看出是那一层出问题，我觉得这对我们定位问题以及维护来说具有莫大的意义，并对异常也进行捕捉，封装成对应的code，我之前阅读一些人的代码发现其项目根本没有做这一层，因为简单而不做我觉得有失所望。

**2）采用hybird模式**

采用hybird模式涉及到资源预加载的问题，在很多项目里面都大量使用，譬如前司的生活服务，就采用了hybird模式，先将资源文件（包含图片、前端页面）打包放到服务器并通过版本号进行管理，并通过一个总的配置文件来管理，如果是H5页面可以进行模板预先设计，down到本地。 配置文件格式：

```
   *文件1*
        name：xxx
        url：http:xxxx
        md5：xxxx

   *文件2*
        name：zzz
        url：http：zzzz
        md5：zzz

```

客户端每次启动应用或者定时请求总的配置文件，通过http code是否是304判断是否需要下载这个总的配置文件，如果code是200，那么下载这个配置，比较那个文件发生变化，并将其下载。这样的好处：

1. 减少接口的交互；
2. 资源预加载，节省流量，打开页面更加流畅，对于服务端来说字需要返回数据json串就行，而不需要其他，减少服务端压力；
3. 方便开发人员，资源管理更加简洁，比如做活动需要的h5页面，只需要前端上传对应的h5资源包到服务端，不需要通过后端开发人员就可以搞定。

虽然这个原理很简单，但是现在很多app还是没有做这个，都是通过填写一个url，加载网页的方式去打开，体验性太不友好。

**3）客户端**

客户端跟服务端就是接口请求的关系，很多时候需要要求客户端做一些数据缓存的工作以及一些检验工作。在前司已经好几次给客户端的同学坑过了，客户端同学接口乱调用，死循环调用。一次是做一个关于事件提醒的功能，需要每天定时调用调用服务端一个接口，结果客户端的同学写了一个bug导致请求每隔一两秒就调用一次，导致服务器这边此接口pv翻了N倍，而且这个bug通过测试同学很难测试出来；还有一次发现服务端一段时间以后UV不见涨，但是PV却涨的很猛，定位发现是客户端同学A图省事在一个方法里面调用了N个接口，也就是模板方法，因为版本更新，同学B需要做一个新的功能，然后也调用了A同学的接口导致，从而导致PV上升，其实B同学完全不需要调用这么多接口。这些都是真实案例，所以这里需要有一个监控接口异常的机制。

**4）思辨大于执行**

写到这里觉得这个非常重要，思辨大于执行，意味着我们不是一股脑就去干，也不是不去干，我们做事情需要思考、辨别；从而让事情更高效、更好、更有力的执行。接口设计也一样，需要我们去思辨。

**5）本地缓存、分布式缓存以及异步**

缓存在前司主要分为客户端缓存、CDN缓存、本地缓存（guava）、Redis缓存。在MZ早期是接口是采用DB+本地缓存的方式提供数据，但这种模式DB压力大，接口吞吐量小，本地缓存多机难一致性、更新不及时问题。为了解决这些问题，引入分布式缓存，并通过Task将业务数据刷到Redis，接口只访问redis，不会访问DB，及时DB故障也不会影响功能。不同的业务系统系统通过MQ来解耦，多机房不是通过MQ来实现数据的一直。比如，评论，先通过写Redis，写MQ来实现数据在多机房同步，再通过task将Redis中评论同步到DB中。

接口设计涉及方方面面，这边也只谈到一个大概，虽然有点泛泛而谈，希望此拙文对你有所启示。

**6）数据库**

数据库分库分表，一般都是通过userId或者imei或者mac地址来分表，单表数据量控制在500w以内，这需要我们提前估算好数据量，尽量避免数据的迁移。在前司，数据库一般都是采用mysql+MongoDB两种，MySQL存储用户的用户数据，MongoDB存储业务数据，就像阅读和生活服务里面的业务数据就存储在MongoDB里面。在数据库这层，我们主要也是通过主从模式、读写分离、分库、分表来实现数据的可用性。

**7）业务**

业务尽可能拆分、独立部署、将项目按业务划分、按功能划分等。譬如生活服务，我们当时主要拆分成管理后台admin、任务task、活动、web、数据展示模块。

**8）数据中心**

每个大一点的公司都有数据部门，我们这边可以通过数据中心的数据分析来达到我们需要的数据。 比如黑名单，推广效果、活动数据。我们可以通过这些完善我们的接口功能。之前在前司做了个数据处理后异步加载到Redis来实现数据利用的项目。