## 内容提要



内容提要：

- 如果游戏需要增加汉字打字功能：每个汉字5分；以倒 S 型路径下落。文中两种设计方案对这个需求变化的响应度如何？
- 适合刚入门Java编程的小白吗?
- 做项目的时候总写着写着就面向过程来做了，怎么培养面向对象的思维方式，在写项目时是先抽象面向对象还是先面向过程在优化的时候再面向对象（JavaScript）？
- 如果某几个对外提供的接口，需要使用类A的部分字段内容，是否一定要为每个接口定义特定的类？
- 在掌握语法的情况下，如何从面向过程的思维转化为面向对象思维，也就是如何训练面向对象的思维？
- 能不能讲讲实际的设计中怎样将面向对象的思想转化为设计的输出物？
- 项目是维护一个很老的代码。现在任务也是增加一些功能，但是仍然是调用他们的基类，请问这种情况下，写新代码时候怎么用上面向对象的思维？
- 如果需要修炼面向对象能力，建议从那些方面入手学习？
- 在对新系统进行设计时，建议先设计类对象还是先确定数据库存储结构好？为什么？

------

**问：如果游戏需要增加汉字打字功能：每个汉字5分；以倒 S 型路径下落。文中两种设计方案对这个需求变化的响应度如何？**

**答：** 我们先来看第一种方案的实现。增加汉字，即是增加了一种字符类型，显然是属于字符的子类。我们的设计可以是这样的：

![图1](http://images.gitbook.cn/73b00730-3c01-11e8-bc10-05fd6e50f299)

在当前设计中只需要扩展一个地方即增加Chinese类，然后改动一个地方，即CharGenerator。这显然是符合面向对象一个很重要的设计原则——开闭原则，即设计方案应该对修改封闭，对扩展开放。

我们再来看第二种方案。在这个方案里，我们新增的汉字类型，是在Char概念范围内的，所以我们不必增加字符子类。但是汉字的移动路径是倒S型，这是一种新的Dropper类型，所以我们需要增加一个Dropper子类。方案是这样的：

![图2](http://images.gitbook.cn/79a991b0-3c01-11e8-bc10-05fd6e50f299)

也是两个地方，增加一个Dropper类，修改一个CharGenerator类，也符合开闭原则。

那这两种方案哪个更好一些呢？

其实这里我们就需要对每个方案中各个概念的职责做整理了。第一种方案中Char既代表字符本身，还包含了分值，又决定着字符的移动路径。第二种方案中，Char代表字符本身，包含着分值，但将移动路径的职责委托给了另一个类即Dropper。这显然使得Char更内聚，Dropper的职责也很明显。所以我觉得第二种方案更好一些。

------

**问：适合刚入门Java编程的小白吗?**

**答：** Java是很多同学的第一门面向对象设计语言。我觉得在学习Java、 C#或Python前，掌握正确的面向对象方法观是非常重要的。现在很多Java课程或书记都更倾向于讲授Java语法，对面向对象只做很少的铺垫，其实是有问题的。这也造成了今天非常多的程序员还是用面向对象的语言，写着面向过程的程序。但说实话，要正确理解和使用面向对象，也不容易。

以我的经验看，你可以先掌握语法，然后投入到真实的项目中，让自己深陷焦油坑，痛苦+绝望。这时候就很关键了，有的人可能认为编程本来就应该这样苦逼，然后便一直陷在技术里面。这时候我们一定要思考，有没有更好的方式解决项目中这些问题。多问问自己，为什么我的代码总是牵一发而动全身。然后你再来看面向对象的这些思想，理解解耦，封装，抽象。这些都是良药。但很遗憾，我看到很多程序员，已经认为苦逼+加班是程序员生活的常态。缺乏去思考或改善自己的设计水平，或只喜欢去钻研具体的技术，比如分布式缓存，数据库等。但其实很多项目中的问题都是设计问题造成的，具体的技术只能缓解症状，但根因在架构设计。

回到这个问题根本。一开始掌握正确的面向对象方法，或者起码在心里知道这一块才是Java的精髓是很重要的。而本文是从“道”的层面告诉大家，面向对象是怎么一回事，它看问题的角度和过程式到底有哪些根本的区别。

------

**问：做项目的时候总写着写着就面向过程来做了，怎么培养面向对象的思维方式，在写项目时是先抽象面向对象还是先面向过程在优化的时候再面向对象（JavaScript）？**

**答：** 培养面向对象的思维的核心就是站在问题领域看用纯类来表达和解决问题，有个词叫Plain Old Java Object(POJO)。然后再考虑持久化，界面显示等技术性问题。当前火热的DDD就是将这个过程体系化了，有一整套方法论来告诉大家如何一步步这么做。

关于“在写项目时是先抽象面向对象还是先面向过程在优化的时候再面向对象”，当然是一开始就面向对象。面向过程和面向对象是两种完全不同的范式，不可能从一种优化到另一种。除非推倒重来。

------

**问：如果某几个对外提供的接口，需要使用类A的部分字段内容，是否一定要为每个接口定义特定的类？**

**答：** 这个问题也是站在实现的角度在看问题，不过如果一个接口只使用一个类中的部分字段，很可能是这个类设计的有问题，不够内聚。考虑将这个类的职责拆分到几个类中去，可能这个问题也就迎刃而解了。

那就是用户类承载的职责过多了。这会面临两种情况。

一种是同一个概念，在多个的上下文中使用。导致职责过载。所以在DDD里有一个概念叫Bounded Context(限界上下文)，即将一个类限定在一个特定的上下文中，这样他的职责便受到约束了。比如在认证上下文中，我们只关注用户的登陆名和密码。而在财务管理上下文中，我们会关注用户的职级，工资等。第二种情况是，如果所有这些信息本来就在一个上下文中，我们可以通过值对象来传递这些部分的值。即将一个实体对象包含多个值对象。这也是DDD里面的典型实践。

------

**问：在掌握语法的情况下，如何从面向过程的思维转化为面向对象思维，也就是如何训练面向对象的思维？**

**答：** 只有在具体的项目实践中练了。推荐几本书《设计模式解析》（可惜已绝版）、《敏捷软件开发——原则、模式与实践》，还有就是《领域驱动设计》。前两本比较通俗易懂，《实现领域驱动设计》也很好。

------

**问：能不能讲讲实际的设计中怎样将面向对象的思想转化为设计的输出物？**

**答：** 我推荐的是在白板前研讨。通过UML简单表示设计的意图和想法就可以了。一些重要的设计可以拍照存档，但不需要有一个重量级的过程专门设计，然后编码。

因为在项目的任何一个阶段，我们对需求的理解都是不完整的，所以要强调迭代。

简单来说就是多沟通，项目组成员间，与客户之间。然后深入理解领域概念，用代码实现，很多时候实现的时候又会发现一些细节理解不够清晰。再回到沟通环节，这便是一个迭代循环了。

------

**问：项目是维护一个很老的代码。现在任务也是增加一些功能，但是仍然是调用他们的基类，请问这种情况下，写新代码时候怎么用上面向对象的思维？**

**答：** 这便是项目重构的问题了。建议对于一些与现有功能耦合性不是很强的功能，逐渐剥离。其实用了面向对象的思维，也要涉及修改的问题，面向对象最大的好处便是让我们的代码可以更容易得适应需求的变化。之所以老代码需要改或重构，很多时候就是因为它没有经过很好的设计，也就是修改成本很高。这是同一个问题的两面。面向对象不能保障你一开始的设计就是最好的，但面向对象能在你对问题的认识更深刻后，很容易对现有的设计进行修改或扩展。

------

**问：如果需要修炼面向对象能力，建议从那些方面入手学习？平时都是面向过程编程。**

**答：** 我介绍一下我自己的经历。最早也是只顾实现功能，根本不care什么设计。然后便陷入了项目焦油坑，加班快加废了，便开始思考有没有更好的做法。于是便看了《设计模式解析》那本书，感觉如获至宝。书中讲了很多面向对象设计的原则，及常用的设计模式。但当掌握了这些原则后，问题便来了，发现自己不会写代码了。因为每写一个类或方法，都发现自己触犯了一些原则。当时快疯了！然后又读了Bob大叔的 《敏捷软件开发——原则、模式与实践》。终于，Bob大叔让我理解了如何将这些原则调和在一起，让其和平相处。不过当时这些理解还是都停留在代码层面，总感觉有一层窗户纸还没有捅破。再后来便又读到了DDD，哇，发现打通了，从需求，到设计，到实现。不过要掌握，关键还是要在实战中多用，才能又更深刻的体会，才会锻炼自己的微观体感。

------

**问：在对新系统进行设计时，建议先设计类对象还是先确定数据库存储结构好？为什么？**

**答：** 建议是前者。后者只是通过一个具体的技术对对象的状态进行保存而已，类和对象才是程序的关键。当类和对象确定后，具体的数据存储是可以有很多种实现方式的，你可以存储在数据库里，也可以存在文件里，也可以存在NOSQL中。对于一些测试需求或演示DEMO，你甚至可以将其存在内存中。比如用MAP来存。所以围绕问题领域，寻找概念，然后确定职责，设计类和对象。最后才是如何显示，如何存储，这些技术细节。



## 文章实录



### 面向过程程序设计

计算机程序=数据结构+算法。这是大学 C 语言教材里非常经典的一句话。这也道出了计算机程序的本质，即通过对一定的数据结构用相应的算法（逻辑）进行处理从而解决用户的问题。这便是 C 之类的过程式语言站在计算机的角度看待编程及软件的经典视角。如下图。

![1](http://images.gitbook.cn/bd89cef0-3322-11e8-a1cf-4d9c1e1337da)

这种基于计算机（实现）视角的软件开发过程通常是这样的：首先梳理业务数据（各种表格、单据、报表等），然后设计数据结构并用代码对其进行表示；接下来分析在真实的业务中对于每一类业务数据需要进行怎样的处理；最后将复杂的处理过程拆解成一个个相对简单的业务步骤并用函数对其进行程序化实现。这样便开发出了满足用户需求的软件。

这种方法的好处显而易见，首先直观明了——用计算机解决现实世界的问题当然要沿着计算机的套路来；其次对于一些业务逻辑不是很复杂的应用，这种方式能提供最简洁的解决方案；但对于业务逻辑比较复杂的项目，这种方式会导致“低内聚，高耦合”的不良代码。但这种方法是如此符合直觉，以至于今天很多使用 Java 或 Python 等面向对象语言的程序员还在用这种过程式思维在写代码。只不过 C 中的结构体变成了 Java 中的“贫血类”（只有属性和 get、set 方法的类），C 中的函数变成了 Java 中的静态方法或无状态类（没有属性的类）方法。为什么会这样呢？因为大家还是站在实现的角度看待面向对象。比如某著名的 Java 教程上对类的定义——“类是具有相同特性和行为的对象集合”。这便是典型的站在实现的角度看待类的方式。那类到底应该是什么？怎样才是面向对象编程的正确姿势呢？

### 面向对象程序设计

我们进行软件开发时需要不停地在两个空间中转换角色——问题空间（包括用户角色、使用场景和具体需求）和解决方案空间（通过组合各种软件组件来满足用户需求）。面向过程方法的思路是站在解决方案空间遥望问题空间，通过将问题空间中的数据和处理流程分别映射进解决方案空间来解决问题。而面向对象则恰恰相反，它鼓励我们立足问题空间，理解需求涉及的各种概念及其职责，然后通过对象和类对其进行表达从而形成解决方案。按照面向对象的本意，**对象描述了问题领域中的某个概念并具有一定的职责**。如何理解这句话呢？

![2](http://images.gitbook.cn/b6140f40-3323-11e8-a1cf-4d9c1e1337da)

其实我们日常生活中的世界便是面向对象的。这也是面向对象技术更擅长表达问题空间的原因。举个例子，看下面某公司的组织架构图。我们看到了是 HR 部，财务部，行政部和软件开发部等，**每个部门都有自己的职责范围**。

![3](http://images.gitbook.cn/c435c410-3323-11e8-a1cf-4d9c1e1337da)

部门有这么几个特点：

1. 提供一定的职责：比如 HR 部门拥有绩效考核，员工技能提升，新人招聘等职责；
2. 自治：比如当 HR 部门接到招聘新人的请求后，会安排部门内部相关人员通过一定的途径从社会上进行招聘。至于安排什么人通过什么途径去招聘，请求发起方统统不用管；
3. （从实现层面来说）拥有资源和流程，这是履行职责的必要条件。

在面向对象编程中我们设计的类和对象也应该具有这三个特点。在一个具体的项目中，我们该如何定义一个类呢？很多面向对象设计的书籍给出的方法是在项目的需求描述中寻找名字。但这种方法存在的问题是对于业务逻辑很复杂的项目，这些名词只能反映浅层的领域知识。如果想提炼出合理的领域概念，从而设计出一个良好的领域模型，通常需要通过多轮迭代精炼才能做到。而这也是《领域驱动设计》这本书里作者花费了大量篇幅想要告诉我们的。如作者所担心的，很多程序员的问题是将大部分精力都投入在研究技术本身，而忽略了问题领域本身。而后者才是《人月神话》中所谓的软件开发中的根本的困难。作者说到“我认为软件开发中困难的部分是规格说明，设计和测试这些概念上的结构，而不是对概念进行表达和对实现逼真程度进行验证。”让我们从发现概念开始。

#### 发现概念

如果你对准确认识问题领域中的概念及其相互关系的困难程度还不以为然的话，让我们再来看一个例子。

下面是我在巴黎拍的一幅照片，从中你看到了什么？

![4](http://images.gitbook.cn/14cb57f0-3324-11e8-a1cf-4d9c1e1337da)

头顶的蓝天和云朵，远处的树木，中间的方尖碑和下面的栏杆等等。我们能轻易识别出的概念有具体的蓝天，云朵，树木，方尖碑和栏杆，同时我们也能识别出更为抽象的空间和距离等概念。这一切是不是很平常？其实一点都不。让我们来看《火星上的人类学家》里提到的一个故事。维吉自幼失明，50岁时哈姆林医生为他做了白内障摘除手术从而得以重见光明。然而，

> 在他初看见的那一刻，他完全不了解自己看见了什么。他看见光、动作与颜色全混杂在一起，都毫无意义，只是一片模糊。后来在一片混沌之中，他听见一个声音说：“怎么样？” 那时他才终于明白这一片光与阴影的混合是一张脸，而且正是他主治医生的脸。

作者又写道，

> 我们一般人生来就看得见东西，根本无法想象这种混乱的情形。对我们来说，生来就有的五种知觉，正常而且相互辅助，一开始就建立起一个视觉世界，**对所见的事物有充分的概念，也明白其意义。**我们每天一早张开眼睛所看到的世界，正是我们穷尽一生学习去看的世界。**世界并非就这样送到我们眼前，而是我们通过不断的经验积累、分类、记忆与链接而创造出来的。**但是维吉张开眼睛的时候，他已经失明了45年，他没有视觉记忆来协助他看懂东西，没有一个经验世界与意义世界等待着他。他的视觉经验只比初生婴儿多一点，而即使是这样，那些经验也早已被忘却。他是看见了，但是他所看见的东西却没有连贯性，不具任何意义。他的视网膜与视觉神经十分活泼，传送着刺激，但他的脑子却理不出其中的意义。 这正是神经学家所说的，辨识不能（Agnosic）。

也就是说手术后的维吉“视而不见”，在他的视野里的只是一片混乱。其实我们所有人刚出生时都是这样的，我们用尽一生“通过不断的经验积累、分类、记忆与链接”从而在混乱中发现概念，建立秩序。其实当我们作为系统分析师或程序员，刚接触一个陌生的业务领域时又何曾不是如此呢？一开始我们面对的只是杂乱的数据和复杂的流程，而**我们需要做的便是从混乱中发现概念，定义职责，和建立秩序。**一些对于正常人来说非常平常的图像概念，比如树，方尖碑和人，对于刚恢复视觉的维吉来说却是非常大的挑战。同样一些在领域专家看来非常平常和普通的概念，对程序员来说却是重重困惑。这就造成了程序员和领域专家的沟通有时非常困难，因为一句平常的业务行话背后其实包含了很多**隐含假设**和**深层概念**，而领域专家并没有意识到程序员其实没有这些背景知识。就如在维吉还没有空间和距离的概念时，你让他理解园艺布局的艺术几乎是不可能的。而挖掘出这些隐含假设和深层概念才是设计出一个优良的领域模型的关键。如何做到呢？DDD 给出的方法是基于统一语言（Ubiquitous Language）与领域专家持续交流，通过不断的重构精炼，最终形成挖掘出深层模型。如何保证领域专家在项目中的参与度呢？Scrum 给出的方法是在项目团队中引入 Product Owner，作为客户需求的代表深度介入进项目。但这并不是说领域专家就是发现概念的权威，这里强调的是程序员与领域专家的互动与沟通。因为有时候，领域专家对需求某些方面的理解也是片面或局限的，只有通过双方的反复沟通与碰撞，才能加深彼此对问题领域的理解。在发现了一个概念后，如何确定其职责呢？

#### 定义职责

职责指的是一个概念承担的责任，具体表现为：能响应哪些请求，对于每种请求需要执行哪些动作及返回什么结果。比如在一个图书管理系统中，外界可以向一个图书对象查询其名称，出版社，及当前借阅者等信息，也可以让其处理借阅和归还等请求。一个概念所承担的职责应该是和概念本身同步产生的。有时一些业务领域中的惯用语可能含义模糊，为了使其职责清晰我们甚至需要对其意义进行重新界定。就如当年牛顿在建立力学模型时所做的那样。

> “回首三个世纪前，当时物理学的发展已经到了难以突破的地步，但随着艾萨克·牛顿将一些古老但意义模糊的词（力、质量、运动，甚至时间）赋予新的含义，物理学的新时代开始了。牛顿把这些术语加以量化，以便能够放在数学方程中使用。而在此之前，motion（运动）一词（仅举此一例）的含义就……含混不清。对于当时遵循亚里士多德学说的人们而言，运动可以指代极其广泛的现象：桃子成熟、石头落地、孩童成长、尸体腐烂……但这样，它的含义就太过丰富了。只有将其中绝大多数的运动类型扬弃，牛顿运动定律才能适用，科学革命也才能继续推进。”（摘自《信息简史》）

软件开发也会遇到相似的情形。比如我参与过为一家中小型制造业企业开发人事管理系统，其中涉及两类雇员，一类是生产车间的工人，另一类是车间管理层和办公室工作人员。两者在管理方式、考勤制度、奖金福利和考核机制等各方面完全不同，每一类又有很多子类。最后我们在项目中将员工的概念窄化成专指第一类人，第二类人我们称之为职员，从而精化了项目的统一语言。这显然和我们日常对这两个名词的理解不一样，但在那个具体的项目中却取得了良好的效果。

我们再通过一个简单的打字游戏来理解一下发现概念和定义职责。字母不断从屏幕上方以一定的速度落下，用户通过按键使相应的字母从屏幕上消失从而得分。但如果屏幕上没有与按键对应的字母则扣分。如果当字母已超出了屏幕的下边界时用户仍未按相应的键，则不得分。得分与扣分规则相同，每个字母一分。最后用户关闭窗口，结束游戏。我们来逐个寻找问题空间中的概念及其职责。最明显的概念便是字母（Letter）了，它的职责包括：（1）返回字母值；（2）在屏幕上下落；（3）销毁（当从屏幕上消失或超出边界时，销毁自己，释放内存）。游戏（Game）当然也是一个概念，它的职责是协调整个程序的执行，具体职责包括：1. 启动；2. 捕获按键动作。用户（User）算一个概念吗？这要看相应的问题空间中有没有合适的职责分配给他。如果是一款多用户在线游戏，并且需要记录每个用户的历史成绩，则用户必然是一个非常重要的概念。但在这款简单的单用户游戏中则没有必要引入这个概念。另外我们需要不停的在屏幕上产生字母，这个职责可以分配给字母类吗？不合适。因为字母的生成逻辑和运行逻辑是完全不同的两套机制。字母生成关注的是以什么频率生成哪种类型的字母，这和字母概念的运行逻辑显然是不同的。所以我们再引入一个字母生成器（LetterGenerator）。它的职责很简单：生成字母。另外当用户每次按键时要计算得分，这需要持有当前屏幕上所有字母的引用，于是我们可以再引入一个分数计算器（ScoreCalculator）。它的职责包括：（1）持有游戏中所有字母；（2）执行按键与字母的匹配，并计算得分。最终的 UML 设计图如下（图中省略了一些实现细节）：

![5](http://images.gitbook.cn/7dbcc590-3325-11e8-a1cf-4d9c1e1337da)

#### 自治

对象对外通过接口接受请求。接口的范围应该刚好覆盖职责，不多也不少。外部不需要也不应该关注对象内部的实现机制。对象对内应该自治，即只与调用方通过接口发生交互，不用被告知自己份（职责）内的事该怎么做，否则便是职责泄露了。贫血模型便是职责泄露最极端的表现。拿上面的打字游戏来说，Letter 类的移动和销毁完全自己负责，不需要其他的类的参与。

#### 继承

继承是面向对象中非常重要的一个概念。很多地方说继承的主要作用是实现代码复用，即子类会天然继承父类的方法从而便于扩展。与对类的误解类似，这也是完全从“实现”角度理解的结果，并且这种看法是非常有害的。从问题空间来理解，继承的本意是用来表述概念之间“is a”关系的即“子类 is a 父类”，每一个子类是父类的一种变化形式。这样理解的好处便是针对父类所写的代码，可以适用于所有子类。这会大大增加系统可扩展性，即未来可以非常灵活地增加新的子类而不用影响调用方代码。所以说**继承是一种封装方式，封装的是父类的各种变化形式**。

作为例子，我们为游戏程序增加如下特性：

1. 支持数字和标点的打字练习；
2. 计分规则改变：字母一分，数字两分，标点符号三分；
3. 字母垂直下落，数字以斜线的路径下落，而标点符号以 S 型的路径下落。

这个需求变更引入了如下一些概念：数字（Number），标点（Punctuation），分值（Score），下落路径（Dropping Path）。显然这里数字，标点和字母是对等的，是键盘上符号的不同类型而已，于是我们便抽象出了一个新的概念——符号（Char）。然后每一种类型又有不同的分值和下落路径。这样我们便抽象出了一个继承体系，如下图（只标出了与上一图的差异部分）：

![6](http://images.gitbook.cn/d7af3330-3325-11e8-a1cf-4d9c1e1337da)

还有没有其他的设计方式呢？如下便是一种（总是想想另一种可能性是一种好习惯）。

![7](http://images.gitbook.cn/e48d9290-3325-11e8-a1cf-4d9c1e1337da)

如果游戏又需要增加汉字打字功能：（1）每个汉字5分；（2）以倒 S 型路径下落。作为作业大家对比一下，以上两种设计方案对这个需求变化的响应度如何？

如果增加的需求是汉字也以斜线下落，以上两种设计方案的响应度又如何？

我们可以在 Chat 交流部分一起来研讨这个问题。

本文中，我们介绍了面向对象的核心思想：

1. 站在问题空间的角度发现概念（即对象）并为其定义职责；
2. 对象应该自治，即封装其内部实现并通过接口与外界交互；
3. 继承是对类型进行封装；装的是父类的各种变化。

本文我们没有谈技“术”，但我们对面向对象设计在“道”的层面做了深层阐述。那如何让这些“道”，以技术的形式落地并形成可行的解决方案呢？欢迎参加下一场 Chat：[DDD（领域驱动设计）的正确姿势](http://gitbook.cn/gitchat/activity/5abb3643ff72ef4e8987404a)。

本文参考书目：

- 《设计模式解析》
- 《领域驱动设计》
- 《火星上的人类学家》
- 《信息简史》