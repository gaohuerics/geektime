## 内容提要

内容提要：

- 两种方案的综合方案，能具体说下这个方案的具体玩法吗？一句话，实际上解决不了大家的实际问题，还是想看你在实际业务中如何解决这个问题的？
- 想问下单日5000万的Log可以设计在mysql里吗？其中event_id不唯一，需要查它20的记录吗？
- 如果是已在线使用的业务系统中的“多key”表应该如何着手进行拆分，操作过程有哪些注意点？
- 有一个user表，里面有用户名字，年龄，性别，还有一个order表存储了user_id 。如果想实时查询所有用户中男，女订单金额总和各排名前10的，在不影响正常业务的情况下，应该如何设计分表查询效率最快？
- 存在多key关系表的前后台系统分离后，如果前端写多读少，后台读多写少，有哪些方法可以保持他们之间数据同步且数据一致（可以允许较少时间延时）？
- 多库的分页和数量count统计，如何做是每个库进行统计和查询，还是有其他的方式？
- 数据统计表结构是一统计纬度一表好，还是一个表中使用key value加type方式好？
- 按不同维度不同应用场景
- ，冗余出多套数据。数据同步是个问题，不同纬度的系统操作对应的数据库，各个数据状态怎么保证实时相互同步？系统开发维护的复杂度高了很多。有什么更好的方案吗？
- 用客户端分库分表与服务器端分库分表各有什么好处，怎么选型？
- 最终一致性有什么好的中间件软件吗？算法自己实现起来要花很多时间吗？由于几乎所有的业务都涉及user这张表，这张表是不是要做冗余同步？
- 在不同纬度的分库分表中，同一条数据更新的相同字段和更新了不同字段。这怎么同步？

------

**问：两种方案的综合方案，能具体说下这个方案的具体玩法吗？一句话，实际上解决不了大家的实际问题，还是想看你在实际业务中如何解决这个问题的？**

**答：**总结中，一句话带过的，具体方案，第六节有详细说明，更具体的，第四五节说的非常细致，应该是能够落地的方案。我再总结下：

多key类前台在线查询，例如`oid/buyer_uid/seller_uid`上都有查询需求，要进行水平切分的话：

1. 用`buyer_uid`来分库 -> 直接满足`buyer_uid`上的查询需求。
2. oid中打入`buyer_uid`中的基因 -> 直接满足oid上的查询需求。
3. `buyer_uid` 和 `seller_uid`冗余一份数据 -> 间接满足`seller_uid`上的查询需求。

------

**问：想问下单日5000万的Log可以设计在mysql里吗？其中event_id不唯一，需要查它20的记录吗？**

**答：**根据我们的经验：

1. 如果log存放在mysql里，可以使用分区表（这是分区表为数不多的应用之一），或者使用按照时间维度分库。
2. 不建议把日志放在mysql里，放在磁盘上压缩，放在阿里云的对象存储里都可以。
3. 如果存在mysql里，需要有另外一个非业务相关的主键。

------

**问：如果是已在线使用的业务系统中的“多key”表应该如何着手进行拆分，操作过程有哪些注意点？**

**答：**如果业务已经使用了多key单表，没有考虑在oid中加入buyer_uid中的基因，随着数据量越来越大，也要逐步做水平拆分，可以这么做：

1. 使用`buyer_uid`分库，一个用户下的所有订单放到一个库上 -> 直接满足`buyer_uid`上的查询需求。
2. 一个索引表，建立oid -> `buyer_uid`的映射关系 -> 间接满足oid上的查询需求，本质也是冗余数据法。
3. 冗余数据 -> 满足`seller_uid`上的查询需求。

------

**问：有一个user表，里面有用户名字，年龄，性别，还有一个order表存储了user_id 。如果想实时查询所有用户中男，女订单金额总和各排名前10的，在不影响正常业务的情况下，应该如何设计分表查询效率最快？**

**答：**数据量大的情况下，要水平切分。水平切分的情况下，join玩不转了。解决方案：将一次数据库交互，转化为多次数据库交互。对于user和order的具体case：

1. 先查uid的信息。
2. 再根据uid查order的list信息。
3. 综合数据返回。

------

**问：存在多key关系表的前后台系统分离后，如果前端写多读少，后台读多写少，有哪些方法可以保持他们之间数据同步且数据一致（可以允许较少时间延时）？**

**答**：前台写多读少，架构设计上不用缓存，水平切分插入后台读多些少，不太可能有这样的后台业务，如果真有，如果能接受一些延时，如文中所述用es/hive来做存储是可以满足需求的。

至于数据同步有两点要注意：

1. 通过MQ来异步同步数据。
2. 如果对于一致性的要求较高，需要有一个机制，定期重建es/hive中的数据。

------

**问：多库的分页和数量count统计，如何做每个库进行统计和查询，还是有其他的方式？**

**答：**夸库分页，是业内没有解决的难题，我在GitChat上有另一场分享专门解答这个问题的。

[《业界难题-“跨库分页”的四种方案》](http://mp.weixin.qq.com/s/h99sXP4mvVFsJw6Oh3aU5A)

大数据，高并发的计数系统，也是一个很有意思的问题，应该采用这样的方案解决。

[《计数系统架构实践一次搞定 | 架构师之路》](http://mp.weixin.qq.com/s/cCnPGRQ6LZHg8-7FRJLaKQ)

------

**问：数据统计表结构是一统计纬度一表好，还是一个表中使用key value加type方式好？**

**答：**数据统一，不同的业务需求，不同的扩展性需求，设计方法不一样。

具体什么例子要空key value的方式来扩展，计数系统的文章是一个典型业务，可以这么扩展，和数据统计业务相近。

------

**问：按不同维度不同应用场景，冗余出多套数据。数据同步是个问题，不同纬度的系统操作对应的数据库，各个数据状态怎么保证实时相互同步？系统开发维护的复杂度高了很多。有什么更好的方案吗？**

**答：**方法如下：

1. 为何会有不同操作系统的需求，有点其他，异构系统，不过也没问题，用MQ还是能够解决。
2. 数据量很大，实时相对比较难，如果同机房，MQ/canal能够做到百毫秒级别延时，业务应该能够接受。
3. 维护复杂度，多维护一个组件MQ/canal。

对于这个问题的补充，其实数据同步没大家想的这么复杂，数据同步 + 保证一致性的方案也是有的。

[《MySQL冗余数据的三种方案 | 架构师之路》](http://mp.weixin.qq.com/s/thG591wNnKX8_ICQS3l3HQ)

------

**问：用客户端分库分表与服务器端分库分表各有什么好处，怎么选型？**

**答：**百度一下，你就知道业内很多分库中间件，各有优缺点，已有的调研文档也有很多。

个人用一句话说下个人理解的优缺点：做在客户端，只能支持一种语言，定制性强。坐在服务端，对调用方透明，但多一次网络交互，实现成本较高（毕竟做在客户端可以根据语言定制）。

------

**问：最终一致性有什么好的中间件软件吗，算法自己实现起来要花很多时间吗？由于几乎所有的业务都涉及user这张表，这张表是不是要做冗余同步？**

**答：**最终一致性，自己实现起来没大家想的这么复杂，更具体的。

[《多对多业务，数据库水平切分架构一次搞定》](http://mp.weixin.qq.com/s/uir4eoHO3wJTdg82k658Lg)

上一次Chat文章中，讲了3种简单的保证最终一致性的方案，可查阅。

不用做冗余，上游做user服务，来屏蔽底层的复杂性。user服务，转化为一个用户中心服务化的问题。

------

**问：在不同纬度的分库分表中，同一条数据更新的相同字段和更新了不同字段。这怎么同步？**

**答：**以下两点：

1. 在线数据冗余方案，只冗余key映射关系，没有冗余元数据，元数据只存一份。
2. 如果冗余元数据，MQ同步变化，业务知道表结构，知道什么字段做了变更，相应的变更就行。

水平切分，不是一个通用方案，不同业务的水平切分方法都不一样。单key业务：用户中心；1对多业务：帖子中心；多对多业务：好友中心；多key业务：订单中心的方案都是不同的。这四个典型业务，我在GitChat上都写了很详细的长文，建议大家再回顾一下，我相信，一定会有收获的。任何脱离业务的架构设计都是耍流氓，共勉。



## 文章实录

### 一、什么是“多key”类业务

所谓的“多key”，是指一条元数据中，有多个属性上存在前台在线查询需求。

**订单中心业务分析**

订单中心是一个非常常见的“多key”业务，主要提供订单的查询与修改的服务，其核心元数据为： Order(oid, buyer*uid, seller*uid, time, money, detail…);其中：

1. oid为订单ID，主键
2. buyer_uid为买家uid
3. seller_uid为卖家uid
4. time, money, detail, …等为订单属性

数据库设计上，一般来说在业务初期，单库单表就能够搞定这个需求，典型的架构设计为：

![enter image description here](http://images.gitbook.cn/c2aed060-8594-11e7-8a06-b904869a238d)

1. order-center：订单中心服务，对调用者提供友好的RPC接口。
2. order-db：对订单进行数据存储。

随着订单量的越来越大，数据库需要进行水平切分，由于存在多个key上的查询需求，用哪个字段进行切分，成了需要解决的关键技术问题：

1. 如果用oid来切分，`buyer_uid`和`seller_uid`上的查询则需要遍历多库。
2. 如果用`buyer_uid`或`seller_uid`来切分，其他属性上的查询则需要遍历多库。

总之，很难有一个完全之策，在展开技术方案之前，先一起梳理梳理查询需求。

### 二、订单中心属性查询需求分析

在进行架构讨论之前，先来对业务进行简要分析，看哪些属性上有查询需求。

**前台访问，最典型的有三类需求：**

- **订单实体查询**：通过oid查询订单实体，90%流量属于这类需求。
- **用户订单列表查询**：通过buyer_uid分页查询用户历史订单列表，9%流量属于这类需求。
- **商家订单列表查询**：通过seller_uid分页查询商家历史订单列表，1%流量属于这类需求。

前台访问的特点：吞吐量大，服务要求高可用，用户对订单的访问一致性要求高，商家对订单的访问一致性要求相对较低，可以接受一定时间的延时。

**后台访问，根据产品、运营需求，访问模式各异：**

按照时间，架构，商品，详情来进行查询。

运营侧的查询基本上是批量分页的查询，由于是内部系统，访问量很低，对可用性的要求不高，对一致性的要求也没这么严格，允许秒级甚至十秒级别的查询延时。

这两类不同的业务需求，应该使用什么样的架构方案来解决呢？

### 三、前台与后台分离的架构设计

如果前台业务和后台业务公用一批服务和一个数据库，有可能导致，由于后台的“少数几个请求”的“批量查询”的“低效”访问，导致数据库的cpu偶尔瞬时100%，影响前台正常用户的访问（例如，订单查询超时）。

前台与后台访问的查询需求不同，对系统的要求也不一样，故应该两者解耦，实施“前台与后台分离”的架构设计。

![enter image description here](http://images.gitbook.cn/eae4d9d0-8594-11e7-bcda-f5e1edc8396a)

前台业务架构不变，站点访问，服务分层，数据库水平切分。

后台业务需求则抽取独立的web/service/db来支持，解除系统之间的耦合，对于“业务复杂”“并发量低”“无需高可用”“能接受一定延时”的后台业务：

- 可以去掉service层，在运营后台web层通过dao直接访问数据层。
- 可以不需要反向代理，不需要集群冗余。
- 可以通过MQ或者线下异步同步数据，牺牲一些数据的实时性。
- 可以使用更契合大量数据允许接受更高延时的“索引外置”或者“HIVE”的设计方案。

解决了后台业务的访问需求，问题转化为，前台的oid，buyer*uid，seller*uid如何来进行数据库水平切分呢？

多个维度的查询较为复杂，对于复杂系统设计，可以逐步简化。

### 四、假设没有seller_uid

订单中心，假设没有`seller_uid`上的查询需求，而只有oid和`buyer_uid`上的查询需求，就蜕化为一个“1对多”的业务场景，对于“1对多”的业务，水平切分应该使用“基因法”。

**再次回顾一下，什么是分库基因？**

通过`buyer_uid`分库，假设分为16个库，采用`buyer_uid`%16的方式来进行数据库路由，所谓的模16，其本质是`buyer_uid`的最后4个bit决定这行数据落在哪个库上，这4个bit，就是分库基因。

**也再次回顾一下，什么是基因法分库？**

在订单数据oid生成时，oid末端加入分库基因，让同一个`buyer_uid`下的所有订单都含有相同基因，落在同一个分库上。

![enter image description here](http://images.gitbook.cn/0ca1c880-8595-11e7-bcda-f5e1edc8396a)

如上图所示，buyer_uid=666的用户下了一个订单：

- 使用buyer_uid%16分库，决定这行数据要插入到哪个库中。
- 分库基因是buyer_uid的最后4个bit，即1010。
- 在生成订单标识oid时，先使用一种分布式ID生成算法生成前60bit（上图中绿色部分）。
- 将分库基因加入到oid的最后4个bit（上图中粉色部分），拼装成最终64bit的订单oid（上图中蓝色部分）。

通过这种方法保证，同一个用户下的所有订单oid，都落在同一个库上，oid的最后4个bit都相同，于是：

- 通过buyer_uid%16能够定位到库。
- 通过oid%16也能定位到库。

### 五、假设没有oid

订单中心，假设没有oid上的查询需求，而只有buyer*uid和seller*uid上的查询需求，就蜕化为一个“多对多”的业务场景，对于“多对多”的业务，水平切分应该使用“数据冗余法”。

![enter image description here](http://images.gitbook.cn/1478eca0-8595-11e7-8901-2b858a5de155)

如上图所示：

1. 当有订单生成时，通过buyer_uid分库，oid中融入分库基因，写入DB-buyer库。
2. 通过线下异步的方式，通过binlog+canal，将数据冗余到DB-seller库中。
3. buyer库通过`buyer_uid`分库，seller库通过`seller_uid`分库，前者满足oid和`buyer_uid`的查询需求，后者满足`seller_uid`的查询需求。

数据冗余的方法有很多种：

1. 服务同步双写。
2. 服务异步双写。
3. 线下异步双写（上图所示，是线下异步双写）。

不管哪种方案，因为两步操作不能保证原子性，总有出现数据不一致的可能，高吞吐分布式事务是业内尚未解决的难题，此时的架构优化方向，并不是完全保证数据的一致，而是尽早的发现不一致，并修复不一致。

最终一致性，是高吞吐互联网业务一致性的常用实践。保证数据最终一致性的方案有三种：

1. 冗余数据全量定时扫描。
2. 冗余数据增量日志扫描。
3. 冗余数据线上消息实时检测。

这些方案细节在“多对多”业务水平拆分的文章里详细展开分析过，便不再赘述。

### 六、oid/buyer*uid/seller*uid同时存在

通过上述分析：

- 如果没有`seller_uid`，“多key”业务会蜕化为“1对多”业务，此时应该使用“基因法”分库：使用`buyer_uid`分库，在oid中加入分库基因
- 如果没有oid，“多key”业务会蜕化为“多对多”业务，此时应该使用“数据冗余法”分库：使用`buyer_uid`和`seller_uid`来分别分库，冗余数据，满足不同属性上的查询需求
- 如果oid/buyer*uid/seller*uid同时存在，可以使用上述两种方案的综合方案，来解决“多key”业务的数据库水平切分难题。

### 七、总结

复杂难题的解决，都是一个化繁为简，逐步击破的过程。

对于像订单中心一样复杂的“多key”类业务，在数据量较大，需要对数据库进行水平切分时，对于后台需求，采用**“前台与后台分离”的架构设计方法**：

- 前台、后台系统web/service/db分离解耦，避免后台低效查询引发前台查询抖动。
- 采用前台与后台数据冗余的设计方式，分别满足两侧的需求。
- 采用“外置索引”（例如ES搜索系统）或者“大数据处理”（例如HIVE）来满足后台变态的查询需求。

对于前台需求，**化繁为简的设计思路**，将“多key”类业务，分解为“1对多”类业务和“多对多”类业务分别解决：

- 使用**“基因法”，解决“1对多”分库需求**：使用`buyer_uid`分库，在oid中加入分库基因，同时满足oid和`buyer_uid`上的查询需求
- 使用**“数据冗余法”，解决“多对多”分库需求**：使用`buyer_uid`和`seller_uid`来分别分库，冗余数据，满足`buyer_uid`和`seller_uid`上的查询需求
- 如果oid/buyer*uid/seller*uid同时存在，可以使用上述**两种方案的综合方案，来解决“多key”业务的数据库水平切分难题**。

数据冗余会带来一致性问题，高吞吐互联网业务，要想完全保证事务一致性很难，常见的实践是最终一致性。